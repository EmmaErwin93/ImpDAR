#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright Â© 2019 David Lilien <dlilien90@gmail.com>
#
# Distributed under terms of the GNU GPL3 license.

"""
Process ApRES data

Author:
Benjamin Hills
bhills@uw.edu
University of Washington
Earth and Space Sciences

Sept 23 2019

"""

def proc_apres_range(dat,p,maxrange=2000,winfun='blackman'):
    """
    # [Rcoarse,Rfine,spec_cor,spec] = fmcw_range(vdat,p,maxrange,winfun)
    #
    # Phase sensitive processing of FMCW radar data based on Brennan et al. 2013
    #
    # Based on Paul's scripts but following the nomenclature of:
    # "Phase-sensitive FMCW radar imaging system for high precision Antarctic
    # ice shelf profile monitoring"
    # Brennan, Lok, Nicholls and Corr, 2013
    #
    # Summary: converts raw FMCW radar voltages into a range for
    #
    # input args:
    # vdat = structure containing shot metadata
    # vdat.vif = data matrix of vltages as digitised with one chirp per row size(nchirps,nsamples)
    # p = pad factor (i.e. level of interpolation to use during fft)
    # maxrange = maximum range to crop output to
    # winfun = window function handle (defaults to blackman)
    #
    # outputs:
    # Rcoarse = range to bin centres (m)
    # Rfine = range to reflector from bin centre (m)
    # spec_cor = spectrum corrected. positive frequency half of spectrum with
    # ref phase subtracted. This is the complex signal which can be used for
    # cross-correlating two shot segements.

    # Craig Stewart
    # 2013 April 24
    # Modified frequencies 10 April 2014
    """

    # Extract variables from structure to make it readable
    fs = vdat.fs;
    T = vdat.T;
    B = vdat.B;
    K = vdat.K;
    ci = vdat.ci;
    fc = vdat.fc;
    lambdac = vdat.lambdac;

    # Processing settings
    N = size(vdat.vif,2);
    xn = round(0.5*(N));
    [nchirps,N] = size(vdat.vif);

    # Measure the sampled IF signal: FFT to measure frequency and phase of IF
    #deltaf = 1/(T*p); # frequency step of FFT
    #f = [0:deltaf:fs/2-deltaf]; # frequencies measured by the fft - changed 16 April 2014, was #f = [0:deltaf:fs/2];
    #Rcoarse = f*ci*T/(2*B); # Range at the centre of each range bin: eq 14 (rearranged) (p is accounted for inf)
    #Rcoarse = [0:1/p:T*fs/2-1/p]*ci/(2*B); # Range at the centre of each range bin: eq 14 (rearranged) (p is accounted for inf)

    nf = round((p*N)/2 - 0.5); # number of frequencies to recover
    #nf = length(f); # changed from above 2014/5/22
    #nf = length(Rcoarse);
    win = window(winfun,N); #chebwin(N);  #rectwin(N); #

    ## Loop through for each shot in burst
    # Calculate phase of each range bin centre for correction
    n = (0:nf - 1)';
    Rcoarse = transpose(n*ci/(2*B*p));
    phiref = 2*pi*fc*n./(B.*p) - (K*n.^2)/(2*B.^2*p.^2); # eq 17: phase for each range bin centre (measured at t=T/2), given that tau = n/(B*p)
    [spec,spec_cor] = deal(zeros(nchirps,nf)); # preallocate
    for ii = 1:nchirps
        vif = vdat.vif(ii,:);
        vif = vif-mean(vif); # de-mean
        vif = win.*vif.'; # windowed
        #vif = [vif; zeros((p-1)*N,1)]; # zero padded to length p*N
        vifpad = zeros(p*N,1);
        vifpad(1:length(vif)) = vif;
        vifpad = circshift(vifpad,-xn); # signal time shifted so phase centre at start
        #plot(vifpad), keyboard
        fftvif = (sqrt(2*p)/length(vifpad)).*fft(vifpad); # fft and scale for padding
        fftvif = fftvif./rms(win); # scale for window
        spec(ii,:) = fftvif(1:nf); # positive frequency half of spectrum up to (nyquist minus deltaf)
        comp = exp(-1i*(phiref)); # unit phasor with conjugate of phiref phase
        spec_cor(ii,:) = comp.*fftvif(1:nf); # positive frequency half of spectrum with ref phase subtracted
    end
    #Rfine = lambdac*angle(spec_cor)/(4*pi); # Distance from centre of range bin to effective reflector: eq 15
    #Rfine = angle(spec_cor)./((4*pi/lambdac) - (4*Rcoarse*K/ci^2)); # this is the full equation including the term generated by the last term in (13)
    Rfine = fmcw_phase2range(angle(spec_cor),lambdac,repmat(Rcoarse,size(spec_cor,1),1),K,ci);
    #R = Rcoarse + Rfine;

    # Crop output variables to useful depth range only
    n = find(Rcoarse<=maxrange,1,'last');
    Rcoarse = Rcoarse(1:n);
    #Rcoarse = repmat(Rcoarse,nchirps,1); # make output same size as Rfine for consistence
    Rfine = Rfine(:,1:n);
    spec = spec(:,1:n);
    spec_cor = spec_cor(:,1:n);

# --------------------------------------------------------------------------------------------

def proc_apres_phase2range(phi,lambdac,rc,K,ci):
    """
    # r = fmcw_phase2range(phi,lambdac,rc,K,ci)
    #
    # Convert phase difference to range for FMCW radar
    #
    # args:
    # phi: phase (radians), must be of spectrum after bin centre correction
    # lambdac: wavelength (m) at centre frequency
    #
    # optional args: (used for precise method)
    # rc: coarse range of bin centre (m)
    # K = chirp gradient (rad/s/s)
    # ci = propagation velocity (m/s)
    #
    # Craig Stewart
    # 2014/6/10
    """

    if nargin<5
        # First order method
        r = lambdac*phi./(4*pi);
    else
        # Precise
        r = phi./((4*pi/lambdac) - (4*rc*K/ci^2));

# --------------------------------------------------------------------------------------------

def meanchirp(Nchirps,fns,plottype=0,fs=40000):
    """
    # fmcw_meanchirp_oneatt(Nchirps,filelist)
    #
    # Calculate mean chirp from chirps spread over multiple bursts and files
    # saves mean chirp in new .mat file.
    #
    # Uses chirp stacking (to burst level) during read to conserve memory
    #
    # args in:
    # Nchirps: number of chirps to average
    # filelist: list of files to use chirps from
    #
    # note: if filelist contains fewer chirps than requested this will use all
    # the chirps available.
    #
    # Craig Stewart
    # 2013-10-02
    # 2014/12/3: added optional cleaning to remove noisey shots from each burst
    """

    if nargin == 0
        #error('Not enough args: must specify number of chirps to average')
        Nchirps = input('Enter the number of chirps to average (may be vector): ');
    end
    if nargin < 2
        #    datafid = fopen('fmcw_data_dir.txt','r');
        #    if datafid == -1
        initpath = pwd;
        #    else
        #        initpath = fgets(datafid); fclose(datafid);
        #    end
        #[filelist, pathname] = uigetfile([initpath,'\*.dat;*.DAT;*.000;*.mat'],'Choose radar file to use chirps from','multiselect','on');
        [filelist, pathname] = uigetfile('*.dat;*.DAT;*.000;*.mat','Choose radar file to use chirps from','multiselect','on');
        #    datafid = fopen('fmcw_data_dir.txt','w'); fprintf(datafid,'#s',pathname); fclose(datafid);
    end
    if isa(filelist,'char')
        filelist = {filelist};
    end

    # Get filename root
    # outputfilenameroot = input('Enter name of average set (default=''test''): ','s');
    # if isempty(outputfilenameroot)
    #     outputfilenameroot = 'test';
    # end
    outputfilenameroot = 'meanchirp'; # just use standard name for output files

    # Loop through number to average
    for nci = 1:length(Nchirps)
        disp(' ')
        disp(['Averaging chirps for N = ' int2str(Nchirps(nci))])
        clear file burstno v n

        # Loop through files
        nchirpstoget = Nchirps(nci);
        ii = 0; # master burst number
        for fn = 1:length(filelist)
            if exist('pathname') == 1
                Filename = [pathname,filelist{fn}];
            else
                 Filename = [filelist{fn}];
            end
            fmt = fmcw_file_format(Filename);
            Burst = 0;

            vdatt.Code = 0;
            while nchirpstoget > 0 && vdatt.Code == 0 # i.e. still need chirps and last read was good
                Burst = Burst + 1;
                # Loop through bursts
                doClean = false; # slower but weeds out bad chirps on the fly
                if doClean
                    vdatt = fmcw_load(Filename,Burst);
                    if vdatt.Code == 0
                        vdatt = fmcw_keep_clean_chirps(vdatt,round(size(vdatt.vif,1)*0.7),0); # best 70# of chirps
                        if size(vdatt.vif,1)>nchirpstoget
                            vdatt.vif = vdatt.vif(1:nchirpstoget,:);
                        end
                        # Now burst stack for consistency with LongBurst case below
                        vdatt.v = sum(vdatt.vif);
                        vdatt.NChirp = size(vdatt.vif,1);
                    end
                else # memory efficient loading of long bursts using burst stacking (cleaning not supported)
                    if fmt==3
                        vdatt = LongBurstRMB3(Filename, Burst, SamplingFrequency, nchirpstoget);
                    elseif fmt ==4
                        vdatt = LongBurstRMB4(Filename, Burst, SamplingFrequency, nchirpstoget);
                    elseif fmt ==5
                        vdatt = LongBurstRMB5(Filename, Burst, SamplingFrequency, nchirpstoget);
                    else
                        error('Unsupported file format')
                    end
                end
                if vdatt.Code == 0
                    vdat = vdatt; # Keep temporary variable if we've had a good read

                    ii = ii + 1;
                    file(ii) = {Filename};
                    burstno(ii) = Burst;
                    v(ii,:) = vdat.v; # stacked NChirp chirps from this burst
                    n(ii) = vdat.NChirp; # number of chirps used
                    nchirpstoget = nchirpstoget - vdat.NChirp;
                    time(ii) = vdat.TimeStamp;
                    disp(['Loaded ' int2str(vdat.NChirp) ' chirps from file ' filelist{fn} ' burst ' int2str(Burst)])
                end
            end
        end
        nchirpsread = Nchirps(nci) - nchirpstoget;

        # Now find average of all chirps
        vdat.v = sum(v,1)/sum(n);
        vdat.ChirpsInBurst = 1;
        vdat.TimeStamp = mean(time);
        vdat.processing = {['Multi-chirp mean produced by ' mfilename ' using ' int2str(sum(n)) ' chirps.']};
        #vdat.Code = -10; # matlab file
        #vdat.Attenuator_1 = mean(vdat.Attenuator_1);
        #vdat.Attenuator_2 = mean(vdat.Attenuator_2);
        FileFormat = fmcw_file_format(Filename);
        if FileFormat == 5
            H = fmcw_ParametersRMB2(Filename);
        elseif FileFormat == 4
            H = fmcw_ParametersRMB1b(Filename);
        end
        vdat.Code = 0;
        if FileFormat == 5 || FileFormat == 4
            vdat.K = H.K;
            vdat.f0 = H.startFreq;
            vdat.fs = H.fs;
            vdat.f1 = H.startFreq + H.chirpLength * H.K/2/pi;
            vdat.SamplesPerChirp = round(H.chirpLength * H.fs);
            vdat.T = H.chirpLength;
            vdat.B = H.chirpLength * H.K/2/pi;
            vdat.fc = H.startFreq + vdat.B/2;
            vdat.dt = 1/H.fs;
            vdat.er = 3.18;
            vdat.ci = 3e8/sqrt(vdat.er);
            vdat.lambdac = vdat.ci/vdat.fc;
    #        vdat.Nsamples = H.Nsamples;
        else
            vdat.er = 3.18;
            vdat = fmcw_derive_parameters(vdat);
        end
        vdat.vif = vdat.v(1:vdat.SamplesPerChirp);
        vdat.Startind(1) = 1;
        vdat.Endind(1) = vdat.SamplesPerChirp;
        vdat.ChirpsInBurst = 1;
        outputfilelist(nci) = {[outputfilenameroot '_n' sprintf('#06u',nchirpsread) '.mat']};
        eval(['save ' outputfilelist{nci} ' vdat']) # note we're just using vdat from the last burst read, but this shouldn't be used anyway??

        if nchirpstoget > 0
            disp(['Warning: only ' int2str(nchirpsread) ' chirps in files selected'])
        end
    end

    if plottype == 1
        fmcw_plot(outputfilelist,'maxrange',4000)
    elseif plottype == 2
        fmcw_plot(outputfilelist,'maxrange',4000,'plotop','r')
    end
