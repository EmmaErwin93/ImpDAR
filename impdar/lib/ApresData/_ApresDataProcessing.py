#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright Â© 2019 David Lilien <dlilien90@gmail.com>
#
# Distributed under terms of the GNU GPL3 license.

"""
Process ApRES data

Author:
Benjamin Hills
bhills@uw.edu
University of Washington
Earth and Space Sciences

Sept 23 2019

"""

import numpy as np
from .load.load_apres import file_format

def proc_apres_range(dat,p,maxrange=2000,winfun='blackman'):
    """
    # [Rcoarse,Rfine,spec_cor,spec] = fmcw_range(dat,p,maxrange,winfun)
    #
    # Phase sensitive processing of FMCW radar data based on Brennan et al. 2013
    #
    # Based on Paul's scripts but following the nomenclature of:
    # "Phase-sensitive FMCW radar imaging system for high precision Antarctic
    # ice shelf profile monitoring"
    # Brennan, Lok, Nicholls and Corr, 2013
    #
    # Summary: converts raw FMCW radar voltages into a range for
    #
    # input args:
    # dat = structure containing shot metadata
    # dat.vif = data matrix of vltages as digitised with one chirp per row size(nchirps,nsamples)
    # p = pad factor (i.e. level of interpolation to use during fft)
    # maxrange = maximum range to crop output to
    # winfun = window function handle (defaults to blackman)
    #
    # outputs:
    # Rcoarse = range to bin centres (m)
    # Rfine = range to reflector from bin centre (m)
    # spec_cor = spectrum corrected. positive frequency half of spectrum with
    # ref phase subtracted. This is the complex signal which can be used for
    # cross-correlating two shot segements.

    # Craig Stewart
    # 2013 April 24
    # Modified frequencies 10 April 2014
    """

    # Processing settings
    N = np.shape(dat.vif,1)
    xn = round(0.5*(N))
    nchirps,N = np.shape(dat.vif)

    # Measure the sampled IF signal: FFT to measure frequency and phase of IF
    #deltaf = 1/(T*p); # frequency step of FFT
    #f = [0:deltaf:fs/2-deltaf]; # frequencies measured by the fft - changed 16 April 2014, was #f = [0:deltaf:fs/2];
    #Rcoarse = f*ci*T/(2*B); # Range at the centre of each range bin: eq 14 (rearranged) (p is accounted for inf)
    #Rcoarse = [0:1/p:T*fs/2-1/p]*ci/(2*B); # Range at the centre of each range bin: eq 14 (rearranged) (p is accounted for inf)

    nf = round((dat.p*N)/2 - 0.5) # number of frequencies to recover
    #nf = length(f); # changed from above 2014/5/22
    #nf = length(Rcoarse);
    win = window(winfun,N) #chebwin(N);  #rectwin(N); #

    ## Loop through for each shot in burst
    # Calculate phase of each range bin centre for correction
    n = np.transpose(np.arange(nf) - 1)
    Rcoarse = np.transpose(n*dat.ci/(2*dat.B*dat.p))
    phiref = 2*np.pi*dat.fc*n/(dat.B*dat.p) - (dat.K*n**2)/(2*dat.B**2*dat.p**2) # eq 17: phase for each range bin centre (measured at t=T/2), given that tau = n/(B*p)
    spec,spec_cor = deal(np.zeros(nchirps,nf)) # preallocate
    for ii in range(nchirps):
        vif = dat.vif[ii,:]
        vif = vif-np.mean(vif) # de-mean
        vif = np.transpose(win*vif) # windowed
        #vif = [vif; zeros((p-1)*N,1)]; # zero padded to length p*N
        vifpad = np.zeros(dat.p*N,1)
        vifpad[:length(vif)] = vif
        vifpad = circshift(vifpad,-xn) # signal time shifted so phase centre at start
        #plot(vifpad), keyboard
        fftvif = (np.sqrt(2*dat.p)/len(vifpad))*fft(vifpad) # fft and scale for padding
        fftvif = fftvif/rms(win) # scale for window
        spec[ii,:] = fftvif[1:nf] # positive frequency half of spectrum up to (nyquist minus deltaf)
        comp = exp(-1j*(phiref)) # unit phasor with conjugate of phiref phase
        spec_cor[ii,:] = comp*fftvif[1:nf] # positive frequency half of spectrum with ref phase subtracted

    #Rfine = lambdac*angle(spec_cor)/(4*pi); # Distance from centre of range bin to effective reflector: eq 15
    #Rfine = angle(spec_cor)./((4*pi/lambdac) - (4*Rcoarse*K/ci^2)); # this is the full equation including the term generated by the last term in (13)
    Rfine = proc_apres_phase2range(angle(spec_cor),lambdac,repmat(Rcoarse,size(spec_cor,1),1),K,ci)
    #R = Rcoarse + Rfine;

    # Crop output variables to useful depth range only
    n = find(Rcoarse<=maxrange,1,'last')
    Rcoarse = Rcoarse[:n]
    #Rcoarse = repmat(Rcoarse,nchirps,1); # make output same size as Rfine for consistence
    Rfine = Rfine[:,:n];
    spec = spec[:,:n];
    spec_cor = spec_cor[:,:n];

# --------------------------------------------------------------------------------------------

def proc_apres_phase2range(phi,lambdac,rc=None,K=None,ci=None):
    """
    # r = fmcw_phase2range(phi,lambdac,rc,K,ci)
    #
    # Convert phase difference to range for FMCW radar
    #
    # args:
    # phi: phase (radians), must be of spectrum after bin centre correction
    # lambdac: wavelength (m) at centre frequency
    #
    # optional args: (used for precise method)
    # rc: coarse range of bin centre (m)
    # K = chirp gradient (rad/s/s)
    # ci = propagation velocity (m/s)
    #
    # Craig Stewart
    # 2014/6/10
    """

    if not all([rc,K,ci]):
        # First order method
        r = lambdac*phi/(4.*np.pi);
    else:
        # Precise
        r = phi/((4.*np.pi/lambdac) - (4.*rc*K/ci**2));

# --------------------------------------------------------------------------------------------

def meanchirp(Nchirps,fns,plottype=0,fs=40000,doClean=False):
    """
    # fmcw_meanchirp_oneatt(Nchirps,filelist)
    #
    # Calculate mean chirp from chirps spread over multiple bursts and files
    # saves mean chirp in new .mat file.
    #
    # Uses chirp stacking (to burst level) during read to conserve memory
    #
    # args in:
    # Nchirps: number of chirps to average
    # filelist: list of files to use chirps from
    #
    # note: if filelist contains fewer chirps than requested this will use all
    # the chirps available.
    #
    # Craig Stewart
    # 2013-10-02
    # 2014/12/3: added optional cleaning to remove noisey shots from each burst
    """

    outputfilenameroot = 'meanchirp'; # just use standard name for output files

    # Loop through number to average
    for nci in rangE(len(Nchirps)):
        print(' ')
        print('Averaging chirps for N = ', str(Nchirps(nci)))

        # Loop through files
        nchirpstoget = Nchirps(nci)
        ii = 0 # master burst number
        for fn in fns:
            fmt = file_format(fn)
            Burst = 0

            datt.Code = 0
            while nchirpstoget > 0 and datt.Code == 0:
                # i.e. still need chirps and last read was good
                Burst = Burst + 1
                # Loop through bursts
                if doClean:
                    datt = fmcw_load(Filename,Burst)
                    if datt.Code == 0:
                        datt = fmcw_keep_clean_chirps(datt,round(size(datt.vif,1)*0.7),0) # best 70# of chirps
                        if size(datt.vif,1)>nchirpstoget:
                            datt.vif = datt.vif[:nchirpstoget,:]

                        # Now burst stack for consistency with LongBurst case below
                        datt.data = sum(datt.vif)
                        datt.NChirp = size(datt.vif,1)

                else:
                    # memory efficient loading of long bursts using burst stacking (cleaning not supported)
                    if fmt==3:
                        datt = LongBurstRMB3(Filename, Burst, SamplingFrequency, nchirpstoget)
                    elif fmt ==4:
                        datt = LongBurstRMB4(Filename, Burst, SamplingFrequency, nchirpstoget)
                    elif fmt ==5:
                        datt = LongBurstRMB5(Filename, Burst, SamplingFrequency, nchirpstoget)
                    else:
                        error('Unsupported file format')

                if datt.Code == 0:
                    dat = datt # Keep temporary variable if we've had a good read

                    ii += 1
                    #file(ii) = {Filename}
                    burstno[ii] = Burst
                    data[ii,:] = dat.data         # stacked NChirp chirps from this burst
                    n[ii] = dat.NChirp      # number of chirps used
                    nchirpstoget = nchirpstoget - dat.NChirp
                    time[ii] = dat.TimeStamp
                    print('Loaded ', str(dat.NChirp), ' chirps from file ', fn, ' burst ', str(Burst))
        nchirpsread = Nchirps(nci) - nchirpstoget

        # Now find average of all chirps
        dat.data = sum(data,1)/sum(n)
        dat.ChirpsInBurst = 1
        dat.TimeStamp = np.mean(time)
        dat.processing = {'Multi-chirp mean produced by ' + mfilename + ' using ' + int2str(sum(n)) + ' chirps.'}
        #dat.Code = -10; # matlab file
        #dat.Attenuator_1 = mean(dat.Attenuator_1);
        #dat.Attenuator_2 = mean(dat.Attenuator_2);
        FileFormat = file_format(fn);
        H.update_parameters()

        dat.Code = 0;
        if FileFormat == 5 or FileFormat == 4:
            dat.K = H.K;
            dat.f0 = H.startFreq;
            dat.fs = H.fs;
            dat.f1 = H.startFreq + H.chirpLength * H.K/2/pi;
            dat.SamplesPerChirp = round(H.chirpLength * H.fs);
            dat.T = H.chirpLength;
            dat.B = H.chirpLength * H.K/2/pi;
            dat.fc = H.startFreq + dat.B/2;
            dat.dt = 1/H.fs;
            dat.er = 3.18;
            dat.ci = 3e8/sqrt(dat.er);
            dat.lambdac = dat.ci/dat.fc;
            #dat.Nsamples = H.Nsamples;
        else:
            dat.er = 3.18;
            dat = fmcw_derive_parameters(dat);

        dat.vif = dat.data[:dat.SamplesPerChirp]
        dat.Startind[1] = 1
        dat.Endind[1] = dat.SamplesPerChirp
        dat.ChirpsInBurst = 1
        outputfilelist[nci] = {outputfilenameroot + '_n' + sprintf('#06u',nchirpsread) + '.mat'}
        eval(['save ' + outputfilelist[nci] + ' dat']) # note we're just using dat from the last burst read, but this shouldn't be used anyway??

        if nchirpstoget > 0:
            print('Warning: only ', str(nchirpsread), ' chirps in files selected')
